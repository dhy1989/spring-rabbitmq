******生产中遇见的问题******
#消息如何保证100%投递成功
    1.保障消息的成功发出
    2.保障MQ节点成功接收
    3.发送端收到MQ节点(broker)确认应答
    4.完善的消息进行补偿机制
    #生产端-可靠性投递
    `方案一`:消息落库,对消息状态进行打标
        |__1.首先对业务数据,消息数据进行持久化,打标
        |__2.发送消息
        |__3.broker应答消息生产者
        |__4.分布式定时任务抓取未成功发送的消息Retry-Send
        |__5.Retry-Send最大次数限制
    `方案二`:消息的延迟投递,做二次检查,回调检查,适合高并发情境   
        
#幂等性的概念
    `方案一`:唯一ID+指纹码机制,利用数据库主键去重
    `方案二`:利用redis的原子性去实现
#在海量订单业务的时候如何保证消息不被重复消费
#Confirm确认消息,Return返回消息
 如何实现confirm确认消息
 1.在channel上开启确认模式:channel.confirmSelect()
 2.在channel上添加监听:addConfirmListener,监听成功和失败的返回的结果,根据具体的结果对消息进行重新发送,或记录日志等后续处理
#消费端限流
 场景;rabbitMq服务器有上万条未处理的消息,我们随便打开个消费者客户端,会出现以下情况
  --巨大的数据瞬间传送过来,我们单个客户端无法同时处理这麽多数据
  rabbitMq提供了qos功能,即非自动确认消息的前提下,如果一定数据的消息(通过基于consumer和channel设置qos的值)未被确认前,不进行消费新的消息
  